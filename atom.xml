<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiong&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-02T10:09:48.874Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiong ren jie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员该何去何从从</title>
    <link href="http://yoursite.com/2018/06/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%E4%BB%8E/"/>
    <id>http://yoursite.com/2018/06/02/程序员该何去何从从/</id>
    <published>2018-06-02T10:09:18.000Z</published>
    <updated>2018-06-02T10:09:48.874Z</updated>
    
    <content type="html"><![CDATA[<p>高薪的IT行业是众多年轻人的职业梦想，然而，一旦身入其中却发觉没有想像中那么美好。被称为IT蓝领的编程员，工作强度大，像个编码”机器”；技术更新换代快，饭碗不稳定。随着年龄的增长，IT编程员该何去何从。</p><p>　　程序员的困惑：我该何去何从</p><p>　　32岁的Smith(化名)已算是IT行业的元老了。大学时代的他，有2/3的时间是在校园微机房里度过的，当时，他疯狂地迷上了电脑。大学毕业后，Smith早早地被一家IT业著名的跨国公司录用，担任程序员。刚进IT行业时，Smith有股火一般的热情，参与了不少项目，而且都成功了。公司对他也很器重，付给他的薪水在当时的同学中可算是天价。在后来的IT泡沫中，Smith的公司也还算稳定。<br>　　<br>　　一晃8年过去了。期间，Smith曾换了两家公司，虽说薪水越来越高，但他却越来越困惑。今年他已经32岁了，以前不觉得，但现在，他感觉程序员的工作强度太大，自己一直在超负荷运转，工作状态就一个字：累。况且，由于这一行的特殊性，从业者必须不断地学习。32岁的程序员虽然技术老到，但毕竟在学习能力、反应速度、工作效率上渐渐地开始和年轻人有了差距，Smith觉得后生可畏，感觉自己的竞争力在缩水。<br>　　<br>　　何况，现在IT业不比以往，面对大量”廉价”的职场新人，老板不仅可以挑肥拣瘦，还可以随时让薪水已涨到一定水平的老人”走人”。Smith的同事Tom(化名)就是这样被公司”请”走的。Smith担心：不知何时，这根裁员的大棒就要挥到自己的头上。目前，虽然自己薪水不低，但”天下没有白吃的午餐”，得到的多付出也就更多。而且业界还有这样的传统，过了35岁，IT编程员就有转岗的可能。未来该何去何从，Smith深感困惑。</p><p>　　寻求职业发展的”第二春”</p><p>　　Smith的处境代表了IT行业一个群体性的问题。有关职业规划师经过对Smith 的处境分析指出，IT人才市场的整体年龄状况趋于年轻化，22岁以下的择业者占总体比例的71%，而35岁以上的只占10%，年轻的人才给市场注入了活力，也使得IT行业的竞争更加白热化–人才流动性很大，岗位相对不够稳定。</p><p>　　程序员是个属于年轻人的职业，”Smith们”如果没有在职业生涯最初的5年或8年时间里得到晋升或实现转型，随着年龄的增长，在技术更新的大潮中便面临竞争力衰减的残酷现实，需要重新定位和转型。 “Smith们”与其咬着牙继续在编程队伍里打拼，还不如重新审核自己的职业兴趣、能力和性格，立足核心竞争力，寻求职业发展的第二春。<br>因此，职业顾问建议热爱IT行业的Smith，可以借助丰富的技术经验和人脉关系寻求发展。</p><p>　　三条出路可选择<br>　　<br>　　出路一：向IT培训师转型</p><p>　　分析：IT 企业在招聘新人后，一般都须经过培训才能上岗，这个培训有时是在岗位上进行的，由富有实践经验的”老人”负责。年轻人想要进入IT行业，必须接受这样的专业培训。如今IT培训市场蛋糕相当大，利润空间可观，行业发展前景看好。根据国际数据公司(IDC)统计数据显示，2004年中国IT培训市场共实现销售额24.4亿元，相比2003年增长了22.1%，2005年市场前景发展更为可观。Smith无论是在IT公司内部转型担任培训工作，还是到IT培训机构担任教师，都应该有发展空间。这样的工作不会有太大压力，且比较稳定，对年龄也没什么要求。更何况，这还没有脱离Smith所喜欢的IT行业。</p><p>　　优势：在这个行业工作了8年，拥有丰富编程、项目经验，曾参与过许多成功案例，这都是Smith的优势。而8年积攒的行业人脉关系，还可以帮助他发展企业客户，顺便担任市场拓展工作。</p><p>　　挑战：Smith在过去8年中一直埋头苦干，只是在公司培训新人时担任过培训工作，缺少培训工作经验。如果要向培训师转型，Smith需要接受一些专业训练，提高担任培训师的能力。</p><p>　　出路二：向IT营销转型</p><p>　　分析：IT 与其它行业不同，由于技术性较强，营销人员一般也须有较强的技术背景，且最好有着丰富经验。互联网公司、电子商务公司、软件公司目前都需要有技术背景的营销人员；另外，电子商务的再度火爆，使得传统企业开始重视电子商务营销，也需要有技术背景的营销人员。这类工作薪水不低，加上提成应该可以拿到高于程序员的薪水，同时也比较稳定。</p><p>　　优势：深厚的技术背景仍然是Smith的核心竞争力，在8年的从业经历中，Smith广泛涉猎了各种编程软件和工具，对IT行业也有相对深入的了解，这些都为他转向营销提供了平台。</p><p>　　挑战：Smith过去的工作主要是跟机器打交道，而营销工作恰恰需要跟人打交道，这对Smith来说是最大的挑战，要求他彻底改变工作方式，加强沟通能力与人际交往能力；此外，营销工作会面临销售指标的压力，这些问题都是Smith转型前必须深入考虑的。</p><p>　　出路三：向项目管理努力</p><p>　　分析：如果说前面两条出路转型的成分多，那么项目管理可以说是Smith更为便捷的发展之路。目前，软件项目经理是人才市场上炙手可热的人才，有丰富经验、外语好的软件项目经理是抢手的香饽饽，供不应求，薪水自然也是水涨船高。在上海市劳动部门新发布的2005年软件行业薪资调查中，项目主管的薪水是同层次主管中最高的，年薪高位数达到211011元，平均年薪达109414元。最重要的是，一个优秀的项目经理可以在这个岗位上长久工作下去，并且有向高层进一步提升的可能。</p><p>　　优势：对Smith这样有经验、有技术、有人脉、有能力、参与过多个软件开发、有一定经验的人，项目管理无疑是Smith发展的一个很好的方向。</p><p>　　挑战：Smith 以往参与过不少项目的开发，但一直是项目团队里的一分子，没担任过项目带头人。而很多公司在招聘项目经理时，都需要有带领团队进行项目开发的经验，这是 Smith的一个劣势。建议他参加一些项目管理方面的培训课程，自学相关的知识，增长自己在流程管理、沟通协调等方面的能力，以便积累资本，逐步向项目管理岗位迈进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高薪的IT行业是众多年轻人的职业梦想，然而，一旦身入其中却发觉没有想像中那么美好。被称为IT蓝领的编程员，工作强度大，像个编码”机器”；技术更新换代快，饭碗不稳定。随着年龄的增长，IT编程员该何去何从。&lt;/p&gt;
&lt;p&gt;　　程序员的困惑：我该何去何从&lt;/p&gt;
&lt;p&gt;　　32岁
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手写HashMap简化版</title>
    <link href="http://yoursite.com/2018/06/02/%E6%89%8B%E5%86%99HashMap%E7%AE%80%E5%8C%96%E7%89%88/"/>
    <id>http://yoursite.com/2018/06/02/手写HashMap简化版/</id>
    <published>2018-06-02T10:07:39.000Z</published>
    <updated>2018-06-02T10:08:18.531Z</updated>
    
    <content type="html"><![CDATA[<pre><code>package cn.map;  import java.util.ArrayList;  import java.util.List;  public class MyHashMap&lt;K, V&gt; implements MyMap&lt;K,V&gt;{      //数组表默认长度      private static int defaultLength = 16;      //负载因子      private static double defaultLoader = 0.75;      //存储元素的表      private Entry&lt;K, V&gt;[] table = null;      //数组中存取元素的个数      private int size = 0;      public MyHashMap() {          this.table = new Entry[defaultLength];      }      public MyHashMap(int length, double loader) {          this.defaultLength = length;          this.defaultLoader = loader;          this.table = new Entry[defaultLength];      }      //这是一个hash算法，根据K对表的长度取余，得到的值就是表的下标      private int getIndex(K k) {          int m = defaultLength;          //得到的可能是一个负值          int index = k.hashCode() % m;          return index &gt;= 0 ? index : -index;      }      @Override      public V put(K k, V v) {          if(size &gt;= defaultLength * defaultLoader) {              upSize();          }          //根据k拿到存储位置,hash计算          int index = getIndex(k);          Entry&lt;K, V&gt; entry = table[index];          if(entry == null) {              size++;          }           table[index] = newEntry(k, v, entry);             return table[index].getValue();      }      //扩容方法，每次扩充一倍      private void upSize() {          Entry&lt;K,V&gt;[] newTable = new Entry[2 * defaultLength];          //数组长度翻倍，元素在表中的位置也要随之改变          reHash(newTable);      }      //新建数组，然后把旧数组中的元素再次进行hash      private void reHash(Entry&lt;K,V&gt;[] newTable) {          List&lt;Entry&lt;K,V&gt;&gt; list = new ArrayList&lt;&gt;();          //把旧表中的全部数据放到list中          for(int i = 0; i &lt; table.length; i++) {              if(table[i] == null) {                  continue;              }              addEntryByNext(table[i], list);          }          //再次hash          if(list.size() &gt; 0) {              size = 0;              defaultLength *= 2;              table = newTable;              for(Entry&lt;K,V&gt; entry : list) {                  if(entry.next != null) {                      //将原始链表结构全部解体                      entry.next = null;                  }                  put(entry.getKey(),entry.getValue());              }          }      }      //将entry所在链表数据全部放入指定list中      private void addEntryByNext(Entry&lt;K,V&gt; entry, List&lt;Entry&lt;K,V&gt;&gt; list) {          if(entry != null &amp;&amp; entry.next != null) {              list.add(entry);              addEntryByNext(entry.next, list);          } else {              list.add(entry);          }      }      private Entry&lt;K, V&gt; newEntry(K k, V v, Entry&lt;K,V&gt; next) {          return new Entry(k, v, next);      }      @Override      public V get(K k) {          int index = getIndex(k);          if(table[index] == null) {              return null;          }          return findEntryByEqKey(k,table[index]);      }      //根据key在entry链表中查找对应元素的value      private V findEntryByEqKey(K k, Entry&lt;K, V&gt; entry) {          if(k == entry.getKey() || k.equals(entry.getKey())) {              return entry.getValue();          } else {              if(entry.next != null) {                  return findEntryByEqKey(k, entry.next);              }          }          return null;      }      @Override      public int size() {          // TODO Auto-generated method stub          return 0;      }      class Entry&lt;K, V&gt; implements MyMap.Entry&lt;K, V&gt; {          K k;          V v;          //next指针，指向下一个链表数据          Entry&lt;K, V&gt; next;          public Entry(K k, V v, Entry&lt;K, V&gt; next) {              this.k = k;              this.v = v;              this.next = next;          }          @Override          public K getKey() {              return this.k;          }          @Override          public V getValue() {              return this.v;          }      }  }  </code></pre><h3 id="JDK中的HashMap具有更加复杂的位运算，大大提高了元素的命中率，所以效率会比简化版HashMap快，但是HashMap的基本原理就是这样"><a href="#JDK中的HashMap具有更加复杂的位运算，大大提高了元素的命中率，所以效率会比简化版HashMap快，但是HashMap的基本原理就是这样" class="headerlink" title="JDK中的HashMap具有更加复杂的位运算，大大提高了元素的命中率，所以效率会比简化版HashMap快，但是HashMap的基本原理就是这样"></a>JDK中的HashMap具有更加复杂的位运算，大大提高了元素的命中率，所以效率会比简化版HashMap快，但是HashMap的基本原理就是这样</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;package cn.map;  

import java.util.ArrayList;  
import java.util.List;  

public class MyHashMap&amp;lt;K, V&amp;gt; implements MyMap&amp;lt
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java多线程详解</title>
    <link href="http://yoursite.com/2018/06/02/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/02/java多线程详解/</id>
    <published>2018-06-02T10:05:35.000Z</published>
    <updated>2018-06-02T10:06:30.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><p>如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。</p><p>用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。</p><p>很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。</p><ul><li><p>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程</p></li><li><p>并行与并发：</p><p>  并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</p><p>  并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1689841-f622a468b2694253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="并行与并发"></p><p>并发与并行</p><ul><li><p>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void transferMoney(User from, User to, float amount)&#123;</span><br><span class="line">to.setMoney(to.getBalance() + amount);</span><br><span class="line">from.setMoney(from.getBalance() - amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p></li></ul><p>好了，让我们开始吧。我准备分成几部分来总结涉及到多线程的内容：</p><p>  1.扎好马步：线程的状态</p><p>  2.内功心法：每个对象都有的方法（机制）</p><p>  3.太祖长拳：基本线程类</p><p>  4.九阴真经：高级多线程控制类</p><h2 id="扎好马步：线程的状态"><a href="#扎好马步：线程的状态" class="headerlink" title="扎好马步：线程的状态"></a>扎好马步：线程的状态</h2><p><img src="https://upload-images.jianshu.io/upload_images/1689841-af3e5b75b44e972c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>线程状态<br><img src="https://upload-images.jianshu.io/upload_images/1689841-383f7101e6588094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>线程状态转换</p><p>各种状态一目了然，值得一提的是”blocked”这个状态：<br>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p><p>&nbsp;&nbsp;1.调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。  </p><p>&nbsp;&nbsp;2.调用wait()，使线程处于等待池(wait blocked pool)，直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool)，<br>&nbsp;&nbsp;释放同步锁使线程回到可运行状态（Runnable）</p><p>&nbsp;&nbsp;3.对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</p><p>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</p><h2 id="内功心法：每个对象都有的方法（机制）"><a href="#内功心法：每个对象都有的方法（机制）" class="headerlink" title="内功心法：每个对象都有的方法（机制）"></a>内功心法：每个对象都有的方法（机制）</h2><p>synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们</p><p><img src="https://upload-images.jianshu.io/upload_images/1689841-a8720771d68cb2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。</p><p>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。</p><p>当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。</p><p>再讲用法：</p><ul><li>synchronized单独使用：<br>   代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Thread1 implements Runnable &#123;</span><br><span class="line">  Object lock;</span><br><span class="line">  public void run() &#123;  </span><br><span class="line">   synchronized(lock)&#123;</span><br><span class="line"> ..do something</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>直接用于方法： 相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。**   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Thread1 implements Runnable &#123;</span><br><span class="line"> public synchronized void run() &#123;  </span><br><span class="line">       ..do something</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>synchronized, wait, notify结合:典型场景生产者消费者问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生产者生产出来的产品交给店员</span><br><span class="line"> */</span><br><span class="line">public synchronized void produce()</span><br><span class="line">&#123;</span><br><span class="line">    if(this.product &gt;= MAX_PRODUCT)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            wait();  </span><br><span class="line">            System.out.println(&quot;产品已满,请稍候再生产&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.product++;</span><br><span class="line">    System.out.println(&quot;生产者生产第&quot; + this.product + &quot;个产品.&quot;);</span><br><span class="line">    notifyAll();   //通知等待区的消费者可以取出产品了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消费者从店员取产品</span><br><span class="line"> */</span><br><span class="line">public synchronized void consume()</span><br><span class="line">&#123;</span><br><span class="line">    if(this.product &lt;= MIN_PRODUCT)</span><br><span class="line">    &#123;</span><br><span class="line">        try </span><br><span class="line">        &#123;</span><br><span class="line">            wait(); </span><br><span class="line">            System.out.println(&quot;缺货,稍候再取&quot;);</span><br><span class="line">        &#125; </span><br><span class="line">        catch (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;消费者取走了第&quot; + this.product + &quot;个产品.&quot;);</span><br><span class="line">    this.product--;</span><br><span class="line">    notifyAll();   //通知等待去的生产者可以生产产品了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>volatile</strong><br>  多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。</p><p>  <img src="https://upload-images.jianshu.io/upload_images/1689841-d4ab6cfda7042c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>  <strong>volatile</strong><br>  针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。</p><h2 id="太祖长拳：基本线程类"><a href="#太祖长拳：基本线程类" class="headerlink" title="太祖长拳：基本线程类"></a>太祖长拳：基本线程类</h2><p>  基本线程类指的是Thread类，Runnable接口，Callable接口<br>  Thread 类实现了Runnable接口，启动一个线程的方法：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread my = new MyThread();</span><br><span class="line">　my.start();</span><br></pre></td></tr></table></figure></p><p>  <strong>Thread类相关方法：</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）</span><br><span class="line">public static Thread.yield() </span><br><span class="line">//暂停一段时间</span><br><span class="line">public static Thread.sleep()  </span><br><span class="line">//在一个线程中调用other.join(),将等待other执行完后才继续本线程。　　　　</span><br><span class="line">public join()</span><br><span class="line">//后两个函数皆可以被打断</span><br><span class="line">public interrupte()</span><br></pre></td></tr></table></figure></p><p>  <strong>关于中断：</strong>  它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。<br>Thread.interrupted()检查当前线程是否发生中断，返回boolean<br>synchronized在获锁的过程中是不能被中断的。</p><p>  <strong>中断是一个状态！</strong>  interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体</p><p>Thread类最佳实践：<br>写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。</p><p><strong>如何获取线程中的异常</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/1689841-8bd65b7f8df6e8d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>不能用try,catch来获取线程中的异常</p><h2 id="九阴真经：高级多线程控制类"><a href="#九阴真经：高级多线程控制类" class="headerlink" title="九阴真经：高级多线程控制类"></a>九阴真经：高级多线程控制类</h2><p>以上都属于内功心法，接下来是实际项目中常用到的工具了，Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。</p><p><strong>1.ThreadLocal类</strong></p><p>用处：保存线程的独立变量。对一个线程类（继承自Thread)<br>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。</p><p>实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。<br>主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。</p><p><strong>2.原子类（AtomicInteger、AtomicBoolean……）</strong></p><p>如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//返回值为boolean</span><br><span class="line">AtomicInteger.compareAndSet(int expect,int update)</span><br></pre></td></tr></table></figure></p><p>该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(b.value.compareAndSet(old, value))&#123;</span><br><span class="line">   return ;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">   //try again</span><br><span class="line">   // if that fails, rollback and log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicReference<br>对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。<br>这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号</p><p><strong>3.Lock类</strong><br>lock: 在java.util.concurrent包内。共有三个实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock</span><br><span class="line">ReentrantReadWriteLock.ReadLock</span><br><span class="line">ReentrantReadWriteLock.WriteLock</span><br></pre></td></tr></table></figure></p><p>主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。</p><p>区别如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序）</span><br><span class="line">提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。</span><br><span class="line">本质上和监视器锁（即synchronized是一样的）</span><br><span class="line">能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。</span><br><span class="line">和Condition类的结合。</span><br><span class="line">性能更高，对比如下图：</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1689841-8a8e93b31bfed934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>synchronized和Lock性能对比</p><p>文／知米丶无忌（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/40d4c7aebd66" target="_blank" rel="noopener">http://www.jianshu.com/p/40d4c7aebd66</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h1&gt;&lt;p&gt;如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。&lt;/p&gt;
&lt;p&gt;用多线程只有一个目的，那就是更好的利用
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/06/02/hello-world/"/>
    <id>http://yoursite.com/2018/06/02/hello-world/</id>
    <published>2018-06-02T09:31:43.415Z</published>
    <updated>2018-06-02T09:31:43.415Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
